<HTML>
<HEAD>
<TITLE>Формат файлов скриптов Fallout 2</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<STYLE TYPE="text/css" MEDIA=screen>
<!--
  BODY  { text-align:  justify; background: gray; color: black }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#ffffff">
<H1 ALIGN="CENTER">Формат файлов скриптов Fallout 2 (*.int)</H1>
<H2>Содержание:</H2>
<OL>
<LI><A HREF="#structure">Структура</A></LI>
<LI><A HREF="#types">Типы данных</A></LI>
<LI><A HREF="#vars">Переменные</A></LI>
<LI><A HREF="#pproc">Функции</A></LI>
<LI><A HREF="#commands">Команды</A></LI>
<OL>
<LI><A HREF="#system-commands">Системные команды</A></LI>
<UL TYPE=circle>
<LI><A HREF="#arithm-commands">Команды арифметических, битовых и логических операций.</A></LI>
<LI><A HREF="#fstack-commands">Команды манипуляций стеком.</A></LI>
<LI><A HREF="#ifgoto-commands">Команды управления.</A></LI>
<LI><A HREF="#extern-commands">Команды манипуляции внешними переменными.</A></LI>
</UL>
<LI><A HREF="#sysapp-commands">Системно-прикладные команды</A></LI>
<UL TYPE=circle>
<LI><A HREF="#getptr-commands">Команды получения адреса объекта.</A></LI>
</UL>
<LI><A HREF="#applic-commands">Прикладные команды</A></LI>
</OL>
<LI>Загадки</LI></OL>
<P><A HREF="opcodes.htm"><I>Приложение</I> А - список команд</A></P>
<HR>
<H3><A NAME="structure">1. Структура</A></H3>
<P>Файл скрипта состоит из:</P>
<UL>
<LI>Стандартного заголовка размером 42 байта </LI>
<LI>Таблицы функций </LI>
<LI>Списка идентификаторов (имен функций и переменных скрипта) </LI>
<LI>Списка строк </LI>
<LI>Кода</LI></UL>
<P>Единственным изменяющимся элементом заголовка является двойное слово по смещению 0Ch, которое указывает на начало кода скрипта. Таблице функций предшествует двойное слово - количество функций. Затем следует сама таблица, состоящая из 24-байтовых записей. Достоверно известно назначение трех полей такой записи:</P>
<UL>
<LI>по нулевому смещению располагается двойное слово, указывающее на смещение имени функции в таблице идентификаторов от начала этой таблицы; </LI>
<LI>по смещению 10h хранится точка входа данной функции (смещение от начала файла); </LI>
<LI>по смещению 14h хранится количество аргументов функции.</LI></UL>
<P>Список идентификаторов начинается с двойного слова - размера списка (размер считается, исключая это двойное слово и завершающее список FFFFFFFFh). Завершается двойным словом -1 (т.е. FFFFFFFFh). Сам список представляет собой последовательность строк хранящихся следующим образом: сначала в слове записывается длина строки, включая завершающие нуль символы, но исключая само это слово. Затем хранится строка, которая завершается одним или двумя нуль символами с тем, чтобы каждая последующая строка имела четное смещение от начала файла (нарушение выравнивания делает скрипт неработоспособным). Адреса строк в скриптах вычисляются от начала раздела (т.е. считая с того адреса, по которому размещен размер раздела) и указывают не на размер строки, а на ее первый символ.</P>
<P>За списком идентификаторов следует список строк, имеющий аналогичную структуру. Если список строк пуст, то может быть записано только FFFFFFFFh.</P>
<P>Код представляет собой последовательность функций, состоящих из команд, которым ниже посвящена отдельная глава. Пока скажем лишь, что начинается раздел кода с последовательности, инициализирующей переменные скрипта. После инициализации происходит переход на начало функции с зарезервированным именем <B>start</B>. Вообще, имена функций в Fallout 2 могут быть совершенно произвольными и включать даже те символы, которые обычно в идентификаторах не допускаются. Например, имя первой функции почти любого скрипта состоит из четырнадцати точек. Кроме того, две функции в таблице скриптов, указывающие на разные строки в качестве имен, могут указывать на один и тот же код. Примером являются те же четырнадцать точек и <B>checkPartyMembersNearDoor</B>.</P>
<P>Важное замечание: все значения в файлах скриптов хранятся в формате Моторола, а не Интел.</P>
<P>&nbsp;</P>
<H3><A NAME="types">2. Типы данных.</A></H3>
<P>Чтобы понять, как в Fallout хранятся данные, нужно сначала уяснить, что все команды скриптов делятся на два типа:</P>
<OL>
<LI>Команды помещения константы в стек</LI>
<LI>Прочие</LI></OL>
<P>Дело в том, что движок Fallout использует распространенную для скриптовых движков стековую модель, когда операнды сначала помещаются в стек, а затем над ними производятся операции, результаты которых возвращаются в тот же стек. Наиболее адекватно такие действия описываются в языках с так называемой бесскобочной логикой, самым известным представителем которых является Форт.</P>
<P>Команды первого типа всегда занимают 6 байт, второго - 2 байта.</P>
<P>На данный момент известно три команды первого типа:</P>
<P>C001 XXXX XXXX - помещает в стек целое число XXXX XXXX</P>
<P>A001 XXXX XXXX - помещает в стек вещественное число в формате Single.</P>
<P>9001 XXXX XXXX - помещает в стек адрес строки. Нужно отметить, что адрес этот в разных контекстах воспринимается по-разному. Обычно это смещение от начала списка строк, но для некоторых команд может быть смещением от начала списка идентификаторов.</P>
<P>Стек в Fallout построен таким образом, что значения хранятся с указанием их типа, причем в 4 байтах с меньшими адресами хранится значение, а в двух байтах с большими адресами - C001, A001 или 9001. Вероятно, что список команд, помещающих значения в стек, не исчерпывается этими тремя. При исследовании обработчиков команд очень часто встречается обработка аргумента с типом 9801.</P>
<P>&nbsp;</P>
<H3><A NAME="vars">3. Переменные</A></H3>
<P>
Все переменные скриптов Fallout можно разделить по времени жизни на статические и динамические. Статическими будем называть те переменные, значения которых сохраняются в сейвах. Все остальные переменные (значения которых хранятся в памяти ограниченное время) - динамические.<BR>
Статические переменные делятся на три класса: глобальные переменные, переменные локации, переменные скрипта.<BR>
Список глобальных переменных с начальными значениями хранится в файле <B>vault13.gam</B>.<BR>
Списки переменных локаций с начальными значениями хранятся в файлах <B>*.gam</B>, одноименных с <B>*.map</B>.<BR>
Количество переменных всех скриптов хранится в <B>scripts.lst</B>.<BR>
Переменные всех трех классов можно добавлять путем изменения соответствующих файлов.
</P>
<P>
Динамические переменные содержатся в стеке. При загрузке скрипта выполняется <A HREF="#c802C">код</A>, инициализирующий динамические переменные скрипта. Аналогично в начале функции выполняется <A HREF="#c802B">инициализация</A> ее переменных.
</P>
<P>&nbsp;</P>
<H3><A NAME="pproc">4. Функции</A></H3>
<P>Как уже было сказано, функции в скриптах Fallout могут именоваться совершенно произвольно. Но для организации реакции скрипта на происходящие в мире Fallout события определен набор специальных имен. Т.е. если, например, в скрипте есть функция с именем <B>talk_p_proc</B>, то она будет вызываться при попытке заговорить с собственником скрипта.</P>
<P>Всего таких предопределенных имен 25 (знак вопроса в скобках означает, что условия вызова данной функции выяснены не окончательно):</P>
<OL>
<LI><B>start</B> - при загрузке скрипта в память (инициализирует динамические переменные скрипта)</LI>
<LI><B>look_at_p_proc</B> - при наведении курсора на объект (краткое описание)</LI>
<LI><B>description_p_proc</B> - при выборе подробного описания (бинокль)</LI>
<LI><B>create_p_proc</B> - при создании объекта-собственника скрипта</LI>
<LI><B>destroy_p_proc</B> - при убийстве/уничтожении объекта</LI>
<LI><B>map_enter_p_proc</B> - при входе чузена в локацию</LI>
<LI><B>map_exit_p_proc</B> - при покидании чузеном локации</LI>
<LI><B>map_update_p_proc</B> (?)</LI>
<LI><B>critter_p_proc</B> - постоянно выполняется, отвечает за поведение в целом.</LI>
<LI><B>talk_p_proc</B> - организация разговора</LI>
<LI><B>use_p_proc</B> - при использовании</LI>
<LI><B>use_obj_on_p_proc</B> - при использовании другого объекта на этом</LI>
<LI><B>use_skill_on_p_proc</B> - при использовании скилла (лечения, воровства, ремонта и т.д.) на этом объекте</LI>
<LI><B>pickup_p_proc</B> - при поднимании с земли (?)</LI>
<LI><B>drop_p_proc</B> - при бросании</LI>
<LI><B>is_dropping_p_proc</B> (?)</LI>
<LI><B>push_p_proc</B> - при попытке сдвинуть криттера с дороги</LI>
<LI><B>spatial_p_proc</B> - срабатывает при прохождении чузена над объектом (для ловушек, например)</LI>
<LI><B>timed_event_p_proc</B> - с каким-то периодом, возможно, имеет отношении к взрывчатке (?)</LI>
<LI><B>combat_is_starting_p_proc</B> - в начале боя</LI>
<LI><B>combat_is_over_p_proc</B> - после боя</LI>
<LI><B>combat_p_proc</B> - выполняется <U>перед</U> каждым ходом криттера в бою</LI>
<LI><B>damage_p_proc</B> - при нанесении криттеру повреждений</LI>
<LI><B>no_p_proc</B> (?)</LI>
<LI><B>none_x_bad</B> (?)</LI>
</OL>
<P>&nbsp;</P>

<H3><A NAME="commands">5. Команды</A></H3>
<P>Для целей классификации команд скриптов мной было принято условное разделение всех команд по степени их связи с собственно игровой моделью Fallout на системные, системно-прикладные и прикладные. В дальнейшем изложении для описания формата команды будет принята следующая нотация:</P>
<I><P>Код команды; ее условное наименование или обозначение; список аргументов в порядке их помещения в стек через запятую; возвращаемое командой значение.</P></I>
<A NAME="system-commands">5.1 Системные команды.</A>
<P><A NAME="#arithm-commands">Команды арифметических, битовых и логических операций.</A></P>
<I><P><A NAME="c8039">8039</A>; +; первое слагаемое, второе слагаемое; результат сложения.</P></I>
<P>Эта команда обрабатывает значения практически любых типов. При сложении целых и вещественных значений возвращается вещественный результат. При сложении строк возвращается строка, являющаяся результатом конкатенации операндов. При сложении строки и числа происходит конкатенация строки со строковым представлением числа. Единственное ограничение данной команды - невозможность сложения числа и строки. </P>
<I>
<P><A NAME="c803A">803A</A>; -; уменьшаемое, вычитаемое; разность.</P>
<P><A NAME="c803B">803B</A>;*; первый множитель, второй множитель; произведение.</P>
<P><A NAME="c803C">803C</A>; /; делимое, делитель; частное.</P>
<P><A NAME="c803D">803D</A>; \; делимое, делитель; остаток.</P>
<P><A NAME="c8046">8046</A>; -; число; число с противоположным знаком.</P>
<P><A NAME="c8044">8044</A>; \; число; целая часть числа.</P>
</I>
<P>Все перечисленные операции допускают как целые, так и вещественные операнды. Последняя команда имеет смысл только для вещественных значений, но допускает и целые операнды, которые возвращает в неизменном виде.</P>
<I>
<P><A NAME="c8040">8040</A>;&amp;; целое, целое; результат побитового И.</P>
<P><A NAME="c8041">8041</A>;|; целое, целое; результат побитового ИЛИ.</P>
<P><A NAME="c8042">8042</A>;^; целое, целое; результат побитового исключающего ИЛИ.</P>
<P><A NAME="c8043">8043</A>;!; целое; результат побитового НЕ.</P>
</I>
<P>Для понимания тонкостей вычисления описываемых ниже команд сравнения и логических команд важно определить, какие значения в Fallout представляют истину, а какие - ложь. Забегая вперед, скажем, что команда ветвления выполняет переход, если ее аргумент-условие равен нулю. Т.е. нуль можно было бы принять за истинное значение. Но при анализе скриптов мы видим, что чаще всего переход осуществляется, чтобы НЕ выполнять какие-либо действия, которые нужно выполнить при соблюдении некоторого условия. Исходя из этого, гораздо удобнее было бы считать, что переход происходит при ложном значении условия, таким образом, любое неотрицательное целое число представляет собой истинное значение, и только нуль - ложь.</P>
<I>
<P><A NAME="c8033">8033</A>;=; число, число; истина, если аргументы равны.</P>
<P><A NAME="c8034">8034</A>;&lt;&gt;; число, число; истина, если аргументы не равны.</P>
<P><A NAME="c8035">8035</A>;&lt;=; число, число; истина, если первый не больше второго.</P>
<P><A NAME="c8036">8036</A>;&gt;=; число, число; истина, если первый не меньше второго.</P>
<P><A NAME="c8037">8037</A>;&lt;; число, число; истина, если первый меньше второго.</P>
<P><A NAME="c8038">8038</A>;&gt;; число, число; истина, если первый больше второго.</P>
<P><A NAME="c803E">803E</A>; AND; булево значение, булево значение; логическое И.</P>
<P><A NAME="c803F">803F</A>;OR; булево значение, булево значение; логическое ИЛИ.</P>
<P><A NAME="c8045">8045</A>; NOT; булево значение; логическое НЕ.</P>
</I>
<P>Булевы значения - целые числа, воспринимаемые в описанном выше смысле.</P>
<P><A NAME="#fstack-commands">Команды манипуляций стеком.</A></P>
<I><P><A NAME="c801A">801A</A>; Del; любое значение; результат не возвращается.</P></I>
<P>Команда просто удаляет элемент с вершины стека.</P>
<I><P><A NAME="c801B">801B</A>; Dup; любое значение; результат - копия элемента.</P></I>
<P>Команда дублирует элемент на вершине стека. С ее помощью можно, например, умножение на 2 записать так:</P>
<P>801B 8039</P>
<I>
<P><A NAME="c8031">8031</A>; нет обозначения; новое значение переменной, номер переменной; результат не возвращается.</P>
<P><A NAME="c8032">8032</A>; нет обозначения; номер переменной; значение переменной.</P>
</I>
<P>Эти команды используются для чтения-записи динамических переменных функции, т.е. таких переменных, которые существуют только во время выполнения данной функции. Для того чтобы эти переменные существовали, сразу после инициализации функции командами помещения значений в стек помещаются начальные значений этих переменных (обычно целые нули). Нужно отметить, что любой переменной в стеке может быть присвоено значение типа, отличного от текущего. Т.е. стековые переменные можно рассматривать как переменные типа Variant.</P>
<I>
<P><A NAME="c8012">8012</A>; нет обозначения; номер переменной; значение переменной.</P>
<P><A NAME="c8013">8013</A>; нет обозначения; новое значение переменной, номер переменной; результат не возвращается.</P>
</I>
<P>Эти команды используются для чтения-записи динамических переменных скрипта, т.е. таких переменных, которые существуют столько, сколько сам скрипт (скрипт объекта в текущей локации существует до тех пор, пока игрок не выйдет из локации). Для того чтобы эти переменные существовали, они инициализируются командами помещения значений в стек в инициализационном коде скрипта.</P>
<P><A NAME="#ifgoto-commands">Команды управления.</A></P>
<P>Команды управления можно подразделить на команды передачи управления, команды инициализации и завершения выполнения и команды вызова функций.</P>
<I><P><A NAME="c8004">8004</A>; goto; адрес перехода; результат не возвращается.</P></I>
<P>Команда безусловного перехода. Адрес перехода - смещение от начала файла.</P>
<I><P><A NAME="c802F">802F</A>; goto; адрес перехода, условие; результат не возвращается.</P></I>
<P>Условный переход, если условие ложно.</P>
<I><P><A NAME="c8030">8030</A>; while; адрес перехода, условие; результат не возвращается.</P></I>
<P>Условный переход, если условие ложно. От предыдущей команды отличается тем, что при истинном условии не удаляет адрес перехода из стека, что обеспечивает в скриптах механизм циклов (для следующей итерации производится безусловный переход на код, вычисляющий условие).</P>
<I><P><A NAME="c802C">802C</A>; нет обозначения; нет операндов; результат не возвращается.</P></I>
<P>С этой команды начинается инициализационный код любого скрипта. Действие ее достоверно не установлено. Но, предположительно, эта команда определяет, что с текущей вершины стека будут отсчитываться индексы динамических переменных скрипта. Инициализация локальных переменных скрипта завершается командой 8003 без аргументов и результата.</P>
<I><P><A NAME="c802B">802B</A>; нет обозначения; нет операндов; результат не возвращается.</P></I>
<P>С этой команды начинается код каждой функции скрипта. Действие ее достоверно не установлено. Но, предположительно, эта команда определяет, что с текущей вершины стека будут отсчитываться индексы динамических переменных функции.</P>
<I><P><A NAME="c800D">800D</A>; return (?); значение для помещения в стек возвратов; результат не возвращается.</P></I>
<P>Эта команда используется в двух описываемых ниже контекстах. А именно: при возвращении результата и при вызове одной функции из другой. Особенности ее применения заставляют предположить, что кроме основного стека в движке Fallout реализован еще и стек возвратов, через который передаются адреса возврата и результаты функций. Вообще говоря, любая функция скрипта возвращает результат. Обычно тело функции завершается последовательностью (подразумевается, что на вершине основного стека находится результат функции):</P>
<P>800D 8019 802A 8029 800C 801C 802A 8029 801C</P>
<P>Кроме того, в теле функции могут быть еще несколько вариантов возвращения результата, тогда используется укороченная последовательность:</P>
<P>800D 8019 802A 8029 800C 801C</P>
<P>Точное действие остальных команд этих последовательностей не установлено, да это и не требуется, т.к. последовательности стандартны и команды эти используются только в них.</P>
<P>Вызов одной функции из другой строится с использованием команд 800D и 8005:</P>
<I><P><A NAME="c8005">8005</A>; call; аргумент1, аргумент2, … , аргументN, количество аргументов, индекс функции в таблице функций (считается от нуля); результат функции.</P></I>
<P>Аргументов может не быть вообще, тогда количество их устанавливается в ноль. Индекс может быть указан как константа командой C001 XXXX XXXX или вычислен из имени функции командой 8028:</P>
<I><P><A NAME="c8028">8028</A>; @; указатель на строку - имя функции; индекс функции.</P></I>
<P>Указатель помещается командой 9001 XXXX XXXX и смещение считается от начала списка строк (а не идентификаторов).</P>
<P>Вызову функции предшествует помещение адреса возврата в стек возвратов. Пример:</P>
<P>Предположим, что адрес команды, следующей за вызовом функции, равен 15E6h. Функция не имеет аргументов и индекс ее равен 5. Тогда вызов функции записывается следующей последовательностью:</P>
<P>C001 0000 15E6 800D C001 0000 0000 C001 0000 0005 8005</P>
<P>Большинство функций в скриптах используются скорее как процедуры, т.е. возвращают всегда нулевой результат, не используемый в дальнейшем. Для удаления такого результата из стека используется описанная выше команда 801A, следующая непосредственно за 8005.</P>
<P><A NAME="#extern-commands">Команды манипуляции внешними переменными.</A></P>
<P>Для организации взаимодействия между скриптами различных объектов в локации используется механизм внешних переменных. Такие переменные объявляются в инициализационном коде скрипта локации и скрипт любого объекта в текущей локации может обратиться к ним по имени.</P>
<I>
<P><A NAME="c8014">8014</A>; нет обозначения; указатель на строку - имя переменной; значение переменной.</P>
<P><A NAME="c8015">8015</A>; нет обозначения; новое значение переменной, указатель на строку - имя переменной; результат не возвращается.</P>
<P><A NAME="c8016">8016</A>; нет обозначения; указатель на строку - имя переменной; результат не возвращается.</P>
</I>
<P>Первые две команды используются для чтения-записи значений внешних переменных. Причем базой для указателей служит начало списка идентификаторов, а не строк. Третья команда используется для объявления внешних переменных в скриптах локаций. Пример:</P>
<P>Предположим, что мы хотим объявить внешнюю переменную, имя которой в списке идентификаторов начинается со смещения 01DAh, и присвоить ей начальное значение 100. Тогда в инициализационном коде скрипта нужно применить такую последовательность:</P>
<P>9001 0000 01DA 8016 C001 0000 0064 9001 0000 01DA 8015</P>
<A NAME="sysapp-commands">5.2 Системно-прикладные команды.</A>
<P><A NAME="#getptr-commands">Команды получения адреса объекта.</A></P>
<P>Для дальнейшего изложения необходимо уточнить, что каждый объект в Fallout имеет идентификатор типа (ObjectID) и адрес (ObjectAddr). Концепция идентификаторов типа описана в документации по протофайлам, а адрес представляет собой просто смещение в сегменте данных. Ниже описываются команды, возвращающие именно ObjectAddr. </P>
<I><P><A NAME="c80BF">80BF</A>; Player; нет аргументов; ObjectAddr игрока.</P></I>
<P>Сам Избранный тоже является объектом Fallout, причем наиболее интересным <FONT FACE="Wingdings">J</FONT> .</P>
<I>
<P><A NAME="c80BC">80BC</A>; Self; нет аргументов; ObjectAddr объекта, которому принадлежит данный скрипт.</P>
<P><A NAME="c80BE">80BE</A>; Self1; нет аргументов; ObjectAddr объекта, которому принадлежит данный скрипт.</P>
</I>
<P>Назначение команды 80BE точно не выяснено, но в большинстве случаев она возвращает то же значение, что и 80BC.</P>
<I><P><A NAME="c80BD">80BD</A>; Sender; нет аргументов; ObjectAddr объекта, вызвавшего данный обработчик.</P></I>
<P>Например, если выполняется функция <B>use_skill_on_p_proc</B>, то 80BD возвращает адрес того, кто применил данный скилл.</P>
<I><P><A NAME="c80C0">80C0</A>; UsedObj; нет аргументов; ObjectAddr использованного на объекте-собственнике скрипта предмета.</P></I>
<P>Имеет смысл в контексте <B>use_obj_on_p_proc</B>.</P>
</BODY>
</HTML>
